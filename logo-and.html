<script type="text/x-red" data-template-name="logo-and">
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="LOGO AND">
  </div>
  <div class="form-row">
    <label for="node-input-inputsCount"><i class="fa fa-sign-in"></i> Anzahl Eingänge</label>
    <input type="number" id="node-input-inputsCount" min="2" max="8">
  </div>
  <div class="form-row">
    <label><i class="fa fa-bolt"></i> Nur bei Zustandsänderung senden</label>
    <input type="checkbox" id="node-input-emitOnChange" checked>
  </div>
  <div class="form-row">
    <label><i class="fa fa-exchange"></i> Negierung pro Eingang</label>
    <div id="negate-container"></div>
  </div>
  <div class="form-tips">
    Eingänge werden über <code>msg.topic = "1" | "2" | ...</code> adressiert. Payload wird zu Boolean konvertiert. Bei einem Node der getrette Ausgänge für True & False hat müssen beide Ausgänge mit dem AND Node als Eingang verbunden werden.
  </div>
</script>

<script type="text/x-red" data-help-name="logo-and">
  <p>LOGO-Style AND-Gatter mit negierbaren Eingängen und Impuls-Speicherzeit.</p>
  <ul>
    <li><b>Anzahl Eingänge:</b> 2–8, über <code>msg.topic</code> adressiert (1-basiert).</li>
    <li><b>Speicherzeit:</b> hält <code>true</code> X Sekunden, explizites <code>false</code> setzt sofort zurück.</li>
    <li><b>Negierung:</b> pro Eingang umkehrbar.</li>
    <li><b>Reset:</b> <code>msg.reset = true</code> löscht Zustände aller Eingänge.</li>
  </ul>
</script>

<script type="text/javascript">
  (function() {
    function buildNegationUI(count, values) {
      const container = $("#negate-container");
      container.empty();
      for (let i = 1; i <= count; i++) {
        const checked = (values && values[i-1]) ? "checked" : "";
        container.append(
          `<label style="margin-right:12px"><input type="checkbox" class="negate-flag" data-idx="${i-1}" ${checked}> Negiere E${i}</label>`
        );
      }
    }

    RED.nodes.registerType('logo-and', {
      category: 'function',
      color: '#FFCC00',
      icon: 'font-awesome/fa-cogs',
      defaults: {
        name: { value: "" },
        inputsCount: { value: 2, required: true, validate: v => v >= 2 && v <= 8 },
        memoryTime: { value: 0, required: true },
        negateInputs: { value: [] },
        emitOnChange: { value: true }
      },
      inputs: 1,
      outputs: 1,
      label: function() {
        return this.name || "LOGO AND";
      },
      oneditprepare: function() {
        const self = this;
        const countEl = $("#node-input-inputsCount");
        // initial UI
        buildNegationUI(parseInt(countEl.val(), 10) || 2, self.negateInputs || []);
        // react to changes
        countEl.on("change", function() {
          const c = Math.max(2, Math.min(8, parseInt($(this).val(), 10) || 2));
          buildNegationUI(c, self.negateInputs || []);
        });
        // restore checkbox states after reopen
        if (Array.isArray(self.negateInputs)) {
          $(".negate-flag").each(function() {
            const i = parseInt($(this).data("idx"), 10);
            if (self.negateInputs[i]) $(this).prop("checked", true);
          });
        }
      },
      oneditsave: function() {
        const count = Math.max(2, Math.min(8, parseInt($("#node-input-inputsCount").val(), 10) || 2));
        let negs = new Array(count).fill(false);
        $(".negate-flag").each(function() {
          const i = parseInt($(this).data("idx"), 10);
          if (!isNaN(i) && i < count) {
            negs[i] = $(this).is(":checked");
          }
        });
        this.negateInputs = negs;
      }
    });
  })();
</script>
